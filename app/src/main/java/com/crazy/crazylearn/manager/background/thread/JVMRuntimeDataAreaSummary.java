package com.crazy.crazylearn.manager.background.thread;

/**
 * Created by feaoes on 2018/4/25.
 */

public class JVMRuntimeDataAreaSummary {

    /**
     * 运行时数据区域
     *
     * https://juejin.im/entry/5a66beabf265da3e283a25ac
     */

    /**
     * 一、程序计数器，
     *      1、一块较小内存空间，可看做当前线程所执行的字节码的行号指示器
     *      2、字节码解释器通过程序技术器选取下一条需要执行的字节码指令
     *      3、线程私有，每条线程都需要一个独立的程序计数器，各线程间计数器互不影响
     *      4、java方法：计数器记录字节码指令地址；Native方法：计数器值为空
     *      5、无异常
     */

    /**
     * 二、Java虚拟机栈
     *      0、为虚拟机使用Java方法（字节码）提供服务
     *      1、线程私有，生命周期与线程相同，描述的是Java方法执行的内存模型
     *      2、存放栈帧(方法执行时创建){存储 -> 局部变量表、操作数栈、动态链接、方法出口等}
     *      3、局部变量表:a、存放编译期可知的各种基本数据类型、
     *                   b、对象引用类型（不等同于对象本身，对象起始地址的指针引用、或代表对象的句柄、或与对象相关的位置）、
     *                   c、returnAddress类型（指向一条字节码指令地址）
     *                   d、局部变量表所需内存空间在编译期间完成分配
     *                   e、在方法运行期间，局部变量表的大小不会改变
     *      4、两种异常：StackOverflowError、 OutOfMemoryError
     */

    /**
     * 三、本地方法栈（Native Method Stack）
     *       0、为虚拟机使用Native方法提供服务
     *       1、两种异常：StackOverflowError、 OutOfMemoryError
     */

    /**
     * 四、Java堆
     *      1、所有线程共享的一块内存区域，虚拟机启动时创建
     *      2、存放对象实例、数组
     *      3、垃圾收集器管理的主要区域：GC堆
     *      4、分代收集算法:细分为：新生代、老年代等...
     *      5、线程私有缓冲区：ThreadLocal等...
     *      6、堆细分为了更快内存分配、更好内存回收...
     *      7、异常：OutOfMemoryError
     */

    /**
     * 五、方法区
     *      1、与堆一样，各个线程共享的内存区域
     *      2、用于存储已被虚拟机加载的类的信息、常量、静态变量等数据
     *      3、异常：OutOfMemoryError
     */

    /**
     * 六、运行时常量池
     *      1、是方法区的一部分
     *      2、类加载后，Class文件中的信息会存放到方法区的运行时常量池
     *          包括：类版本、字段、方法、接口等描述信息；还有常量池（Constant Pool Table）
     *      3、运行时常量池相对于Class文件常量池，具备动态性，常量在编译期间或运行期间都可以进入运行时常量池
     *      4、异常：OutOfMemoryError
     */

    /**
     * 七、直接内存
     *      1、并不是虚拟机运行时数据区的一部分、也不是Java虚拟机规范中定义的内存区域、有可能导致OutOfMemoryError
     *      2、物理中内存的一部分
     */


    /***
     *
     * 1、引用计数法
     * 2、可达性分析法
     *
     * 垃圾回收算法：（理论）
     * 1、标记清除算法
     *      效率低
     *      碎片化严重
     * 2、复制算法
     *      将空间分为两块，每次只对其中一块GC,当一块内存使用完，就将存货的对象复制到另一块
     *      （1：1分块）空间利用率不足
     *      （8：1：1）分为:一大：伊甸园区Eden、两小：幸存者区Survivor
     * 3、标记整理算法
     *      争对老年代：将存活的对象移动到内存一端
     * 4、分代回收算法
     *      根据存活对象分为几块内存区域，年轻代，老年代，然后根据各个年代制定不同的回收算法
     *    新生代
     *      每次GC都有大量的对象死去，只有少量存活，选用复制算法比较合理
     *    老年代
     *      老年代对象存活率高，没有额外的空间分配，所以必须清除，标记清除、标记整理、
     *
     * HotSpot垃圾回收器(实践
     * 1、Serial（串行）收集器
     *      单线程收集器，进行垃圾回收时，必须暂停其他工作线程直到收集结束
     *      如：新生代：复制算法，老年代：标记整理算法
     * 2、ParNew收集器
     *      Serial多线程版本
     *  （单线程收集阻塞用户线程、多线程交替收集）
     * 3、Parallel Scavenge收集器
     *   新生代收集器：复制算法实现，并行的多线程收集器
     *   CMS等收集器的关注点：缩短垃圾回收时用户线程的停顿时间
     *
     * 作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，
     * 动态调整停顿时间。这就是 GC 的自适应调整策略(GC Ergonomics)。
     *
     * 4、Serial Old收集器
     *      收集器的老年代版本，单线程，标记整理算法
     *
     * 5、Parallel Old收集器
     *      Parallel Old 是 Parallel Scavenge 收集器的老年代版本。多线程，使用 标记 —— 整理
     * 6、CMS 收集器
     *      是一种以获取最短回收停顿时间为目标的收集器。基于 标记 —— 清除 算法实现。
     * 7、G1收集器
     *      面向服务端的垃圾回收器
     *      优点：并行与并发、分代收集、空间整合、可预测停顿。
     *
     */

    /***
     *  内存分配与回收策略
     *  1、对象优先在 Eden 分配
     *      新生代 GC (Minor GC) 发生在新生代的垃圾回收动作，频繁，速度快。
     *      老年代 GC (Major GC / Full GC) 发生在老年代的垃圾回收动作，出现了 Major GC 经常会伴随至少一次 Minor GC(非绝对)。Major GC 的速度一般会比 Minor GC 慢十倍以上。
     *  2、大对象直接进入老年代
     *  3、长期存活的对象将进入老年代
     *  4、动态对象年龄判定
     *  5、空间分配担保
     *
     *
     */

    /***
     *
     * 1、类加载器
     *      通过一个类的全限定名来获取描述此类的二进制字节流。
     *
     * 2、双亲委派模型
     *    从 Java 虚拟机角度讲，只存在两种类加载器：
     *      启动类加载器（C++ 实现，是虚拟机的一部分）
     *      其他所有类的加载器（Java 实现，独立于虚拟机外部且全继承自 java.lang.ClassLoader）
     *
     *   启动类加载器
     *      加载 lib 下或被 -Xbootclasspath 路径下的类
     *   扩展类加载器
     *      加载 lib/ext 或者被 java.ext.dirs 系统变量所指定的路径下的类
     *   应用程序类加载器
     *      ClassLoader负责，加载用户路径上所指定的类库。
     *
     *   工作过程：如果一个类加载器收到一个类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器。只有父类无法完成时子类才会尝试加载。
     *
     *   jvm并没有指明需要从Class文件中获取，也可以通过ZIP包、网络、动态代理方式或者是其它文件数据库等资源类型中获取二进制字节流。
     */

}
