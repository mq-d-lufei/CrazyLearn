package com.crazy.crazylearn.jvm;

public class JVMSummary {

    /***
     *
     *  一、Java内存区域与内存溢出异常
     *
     *    0、Java与C++之间：内存动态分配、垃圾回收策略
     *
     *  运行时数据区
     *
     *   1、程序计数器（program Counter Register）
     *      1、一块较小的内存空间，当前线程所执行的字节码的行号标识器，
     *      2、并发、循环、跳转、异常处理、线程恢复等基础功能都需要计数器来选取下一条需要执行的字节码指令
     *      3、线程私有内存，各个线程独立存储、互不影响
     *      4、Java方法，计数器的值为正在执行的字节码指令地址，
     *         Native方法：计数器指为空
     *      5、没有OutOfMemoryError情况
     *
     *   2、Java虚拟机栈（VM Stack）
     *      1、线程私有
     *      2、生命周期与线程相同，
     *      3、描述的是Java方法执行的内存模型：
     *          栈帧：每个方法在执行的同时，都会创建一个栈帧（Stack Frame）,用于存储：
     *          a、局部变量表、
     *              存储编译期可知的基本类型、对象引用类型、不等同于对象本身，可能是一个指向对象起始地址的指针
     *              long\double占用2个局部变量空间，其余占用1个
     *              局部变量表所需空间在编译时确定，运行时不会改变大小
     *
     *              1、一组变量值存储空间，用于存储方法参数、方法内部定义的局部变量
     *
     *          b、操作数栈
     *              后入先出的栈
     *          c、动态链接
     *
     *          d、方法出口等信息
     *
     *          每个方法从调用到执行完成的过程，对应着一个栈帧入栈出站的过程
     *
     *          当前栈帧：在活动线程中，质优位于栈顶的栈帧才时有效的
     *
     *          异常情况：
     *             StackOverflowError：线程请求的栈的深度大于虚拟机锁允许的深度
     *              OutOfMemoryError:虚拟机栈扩展时无法申请到足够内存
     *
     *   3、本地方发展（Native Method Stack）
     *      与Java虚拟机栈类似
     *      为虚拟机执行Native方法服务
     *
     *      异常情况：
     *         StackOverflowError：线程请求的栈的深度大于虚拟机锁允许的深度
     *         OutOfMemoryError:虚拟机栈扩展时无法申请到足够内存
     *
     *   4、Java堆（Heap）
     *      1、Java虚拟机所管理的内存中最大的一块
     *      2、所有线程共享的一块内存区域，在虚拟机启动时创建
     *      3、唯一目的：存放对象实例，对象实例在这里分配内存
     *      4、垃圾收集器管理的主要区域（称作：GC堆）
     *      5、划分区域方式：
     *          内存回收角度：（分代收集算法）：
     *              新生代、老年代等
     *          内存分配角度：
     *              在线程共享的Java堆中划分出多个线程私有的缓冲区
     *          无论如何划分，都与存放内容无关，无论哪个区域，都仍然存储的时对象实例，进一步划分为了更好地回收内存，或者跟快分配内存
     *
     *       异常情况：
     *           OutOfMemoryError:对重没有内存完成对象实例分配并且堆也无法再扩展时
     *
     *  5、方法区（Method Area）
     *      1、线程共享的内存区域
     *      2、存储已经被虚拟机加载的类信息、常量、静态常量、即时编译器编译后的代码等数据
     *      3、Java虚拟机规范：将方法区表述为堆的逻辑部分
     *      4、别名（非堆），与Java堆区分
     *
     *       异常情况：
     *         OutOfMemoryError:当方法区无法满足内存分配需求时
     *
     *  6、运行时常量池（Runtime Constant Pool）（方法区中）
     *      1、方法区的一部分
     *      2、Class文件中：除了类的版本、字段、方法、接口等标书信息外，另一项信息是：常量池
     *      3、存放编译器生成的各种字面量和符号引用，在类加载后进入方法区的运行时常量池存放
     *      4、运行期间也可以将新的常量放入常量池，如String类的intern()
     *
     *       异常情况：（受方法区内存限制）
     *          OutOfMemoryError:当常量池无法再申请到内存时
     *
     *  7、直接内存（Direct Memory）（不在运行时数据区中）
     *      1、不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范定义的内存区域
     *      2、NIO(New Input/Output)类，引入一种基于通道（Channel）与缓冲区（Buffer）的I|O方式
     *         它可以使用Native函数库直接分配堆外内存，可提高性能，避免了在Java堆与Native堆中来回复制数据
     *
     *       异常情况：(受本机内存影响)
     *           OutOfMemoryError:无法再申请到内存时
     *
     *
     *  HotSpot虚拟机对象探秘
     *
     *  0、以常用虚拟机HotSpot和常用内存区域Java堆为例，谈到HotSpot虚拟机在Java堆中对象的分配、布局和访问的全过程
     *
     *  1、对象的创建
     *  2、对象的内存布局
     *  3、对象的访问定位
     *      句柄访问方式：
     *          栈（本地变量表（reference存放句柄地址）） --> 堆（句柄池(实例指针)） --> 堆（实例池（实例数据|类型数据指针）） -->方法区(类型数据)
     *      直接指针访问：（HotSpot使用）
     *          栈（本地变量表（reference存放对象地址）） --> 堆（对象实例数据(类型数据指针)） -->方法区(类型数据)
     *          效率：速度快，节省一次指针定位开销
     *  4、OutOfMemoryError
     *
     *
     *
     *  垃圾收集器与内存你分配策略
     *
     *  对象存活判定算法：
     *
     *  1、引用计数算法
     *      很难解决对象间相互引用问题，引用计数都不为一，无法通知GC回收
     *  2、可达分析算法
     *      从GCRoot到这个对象不可达时，则证明该对象是不可用的
     *      Java中可作为GCRoot的对象：
     *          虚拟机栈（栈帧中的本地变量表）中引用的对象
     *          方法区中类静态属性引用的对象
     *          方法区中常量引用的对象
     *          本地方法栈中JNI引用的对象
     *  3、引用
     *      强引用：垃圾回收器永远不会回收掉被引用的对象
     *      软引用：软引用的对象在垃圾回收时不会被回收，只有当内存不够用时才会真正回收，适合缓存的场合
     *              描述一些还有用但并非必要的对象，在系统将要发送内存溢出之前,将会把这些对象列入回收范围之中进行的第二次回收，若回收后内存依然不够，则抛出内存溢出异常
     *      弱引用：描述非必须对象，比软引用更弱，无论内存是否足够，在垃圾收集后，该对象肯定被回收
     *      虚引用：回收时有通知
     *  4、finalize() 从使用到忘记
     *
     * 垃圾收集算法
     *
     *  1、标记--清除算法
     *  2、复制手机算法
     *  3、标记--整理算法
     *  4、分代收集算法
     *      Java堆：新生代、老年代
     *
     *
     *  Java虚拟机垃圾收集策略
     *
     *  1、Serial Collector
     *      任何事可都只有一个线程进行垃圾收集
     *  2、Parallel Collector
     *  3、Concurrent Collector
     *
     *
     *  Java虚拟机垃圾收集算法
     *
     *  1、标记-清除算法（Mark Sweep）
     *     分为标记、清除两个阶段
     *     首先标记出所有需要回收的对象，编辑完成后统一回收所有被标记的对象
     *     缺点;效率低、内存碎片多
     *  2、复制算法
     *  3、标记整理算法（Mark Compact）
     *  4、分代收集算法
     *      分局对象的存活时间，Java堆分为老年代与新生代
     *      新生代：标记-复制算法
     *      老年代：标记-清除算法或标记-整理算法
     *
     *
     *  垃圾收集器
     *
     *  1、Serial 收集器
     *      Stop The World
     *
     *
     */

    /***
     *
     *  GC 类加载器、内存
     *
     */

    /***
     *
     * 1、 Java虚拟机
     *    平台无关性：
     *       虚拟机提供商发布了许多可以运行在不同平台上的虚拟机，
     *       这些虚拟机都可以装载执行同一种平台无关的字节码，从而实现“一次编译，导出运行”
     *    语言无关性：
     *      让其他语言运行在Java虚拟机之上（jdk1.7-1.8: JVM设计者通过JSR-292基本兑现了承诺）
     *
     *    关联：
     *      Java虚拟机只与“Class文件”这种特定的二进制文件格式关联
     *
     *  2、Class文件：
     *      1、包含Java虚拟机指令集、符号表、若干其他辅助信息
     *      2、使用Java编译器可以把Java代码便以为存储字节码的Class文件，
     *         使用JRuby等其他语言的编译器一样可以把程序代码编译为Class文件，
     *         所以：虚拟机并不关心Class的来源是何种语言
     *
     *         不同语言编写的程序代码（*。java|*.kt|*.rb） --> 编译器（javac|jRubyc编译器） --> 字节码（*。class）--> java虚拟机
     *      3、Java语言中的各种变量、关键字、运算符号的语义，最终都是有多条字节码命令组合而成，
     *          因此字节码命令停工的语义描述功能肯定比Java语言本身更加强大。
     *          因此，字节码命令语义描述功能为一些有别于Java语言特性的语言提供了基础
     *
     * 3、Class文件结构：
     *      1、一组以8位字节为基础单位的二进制流，各个数据严格按照顺序紧挨着排列在Class文件中，中间没有任何分隔符，
     *          当遇到占用大于8位的数据项，按照高位在前的方式分割为若干个8位存储
     *      2、头部包含魔数、版本号等信息，用于标识虚拟机是否可以执行     *
     *      3、常量池
     *      4、存储字面量与符号引用
     *           Class文件中不回保存各个方法、字段的最终内存布局信息
     *
     *      5、访问标识：
     *          如Class是类还是接口，是否为public，是否有abstract等信息
     *      6、字段表
     *           描述接口或类中声明的变量、字段（类级别变量、实例级别变量）
     *      7、方发表
     *           描述方法
     *      8、属性表
     *
     *  4、字节码指令集
     *      0、Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数指令都不包含操作数，只有一个操作码
     *      1、运算指令、类型转换指令、操作数栈管理指令、控制转移指令、方法调用和返回指令、异常处理指令等等...
     *      2、对象创建与访问指令
     *          类实例和数组创建后，可以通过对象访问指令获取对象实例或数组中的元素
     *      3、同步指令（Monitor）
     *          a、Java虚拟机支持：方法级同步、方法内部一段指令序列的同步
     *          b、方法级的同步是隐式的，即不许通过字节码指令来控制，实现在方法调用和返回之中
     *          c、虚拟机可以通过方发表结构中的AAC_SYNCHRONIZED访问标识值得知方法是否生命为同步方法
     *          d、同步一段指令序列，由java中synchronized语句块表示，Java虚拟机中的指令集中有
     *              monitorenter和monitorexit两条指令支持synchronized关键字的语义
     *
     *
     */

    /***
     *
     *  Java虚拟机 类加载机制
     *
     *  1、虚拟机如何加载Class文件？Class文件信息进入虚拟机会发生何种变化？
     *      虚拟机类加载机制：虚拟机将描述类的数据重Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可悲虚拟机世界试用的Java类型
     *  2、类家在时机
     *      1、初始化：
     *         对一个类主动引用
     *         被动引用
     *
     *
     *  Java虚拟机执行引擎
     *
     *  1、运行时栈帧
     *      JVM运行时数据区中Java虚拟机栈的栈元素
     *
     */

    /***
     *
     *  Java虚拟机的数据类型
     *      byte 1
     *      short 2
     *      int 4
     *      long 8
     *      float 4
     *      double 8
     *      char 2
     *      object 4
     *      returnAddress 4
     *
     *   所有java类型检查都在编译时完成
     *
     *  Java虚拟机的体系结构
     *
     *  以下是5个逻辑组成：
     *   1、一组指令集
     *   2、一组寄存器
     *   3、一个栈
     *   5、一个方法区
     *   4、一个垃圾收集堆
     *
     *   1、指令集
     *      相当于Java程序的汇编语言，指令包含一个单字符的操作符和0个或多个操作数（操作数大于一个字节时，高字节在前）
     *   2、寄存器
     *      保存机器的运行状态，所有寄存器都是32位，Java虚拟机有如下4种寄存器：
     *      a、pc:Java程序计数器
     *      b、optop:指向操作数栈 顶端的指针
     *      c、frame:指向当前执行方法的执行环境的指针
     *      d、vars:指向当前执行方法的局本部变量区第一个变量的指针
     *      Java虚拟爱是栈式的，它不定义或使用寄存器来传递或接收参数，目的是为了保证指令的简洁和实现的高效,特别是寄存器不多的处理器
     *   3、栈
     *   4、堆
     *   5、方法区
     *
     *  Java虚拟机的生命周期
     *      main(）方法的开始到守护线程的结束
     *      只要还有非守护线程在运行，那么这个Java程序也在继续执行（虚拟机也依然存活）
     *
     */

    /***
     *
     *  Android虚拟机 ------ Dalvik VM
     *
     *  1、基于寄存器
     *  2、可以支持已近转为.dex格式的Java应用程序，
     *  3、.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统
     *  3、一般而言，基于栈的机器需要更多的指令，基于寄存器的机器指令更大
     *
     *  与JVM区别
     *  1、android2.2开始支持JIT
     *  2、Dalvik有自己的字节码（bytecode）,并非使用 Java bytecode
     *  3、Dalvik VM基于寄存器，JVM基于堆栈
     *  4、Dalvik VM通过Zygote进行Class Preloading,Zygote会完成虚拟机的初始化
     *
     *  Dalvik VM主要特征
     *
     *  1、原来每个类文件中的常量池，在.dex文件中由一个常量池来管理
     *  2、每一个Android应用都运行在一个Dalvik VM实例里，而每个虚拟机实例都是一个独立的进程空间
     *  3、虚拟机的线程管理、内存分配和管理、Mutex等都依赖于底层操作系统实现
     *  4、所有Android应用的线程都对应一个Linux线程，虚拟机因而可以依赖操作系统的线程调度和管理机制
     *  5、不同的应用在不同的进程空间中运行，堆不同来源的应用都是用不同的Linux用户来运行，保证应用的安全和独立运行
     *  6、Zygote是一个虚拟机进程，同时也是一个虚拟机实例的孵化器，每当系统要求执行一个Android应用程序，
     *      Zygote都会孵化出一个子进程来执行该应用程序。
     *      Zygote进程是在系统启动时产生的，他会完成虚拟机的初始化、库的加载、预置类库的加载和初始化等操作，、
     *      而在系统需要一个新的虚拟机时，Zygote通过复制自身，最快锁的提供一个系统。
     *      另外，对于一些只读的系统库，所有虚拟机实例和Zygote共享一块内存区域，这样可以大大节省内存开销
     *  7、相对于堆栈架构的虚拟机，基于寄存器的虚拟机实现，虽然在硬件通用性上更差一些，但在代码的执行效率上更胜一筹，
     *      基于寄存器的虚拟机，可以更加有效的减少冗余指令的分发和减少内存的读写访问
     *
     *  Dalvik的进程管理
     *
     *  1、依赖于Linux的进程体积结构
     *  2、Zygote是一个虚拟进程，同时也是一个虚拟机实例的孵化器，通过init进程启动。
     *  3、首先会孵化出System_Server,每当系统要执行Android应用程序是，Zygote会利用Linux会fork产生一个子进程来执行该应用
     *
     *
     *
     *  内存分配管理
     *      JVM内存模型\运行时数据区部分
     *
     *    Dalvik虚拟机内存分配 Dalvik虚拟机内存分配
     *
     *    1、内存你分配
     *       对象布局
     *       堆
     *       堆内存位图
     *       堆的内存管理
     *       dvmAllocObject
     *
     *    2、内存回收
     *    3、内存你管理调试
     *
     *
     */

    /***
     *
     *  ART
     *
     *  1、
     *
     */
}
