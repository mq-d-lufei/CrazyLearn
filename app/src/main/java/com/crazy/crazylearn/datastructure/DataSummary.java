package com.crazy.crazylearn.datastructure;

/***
 * 集合 并发 SQL JVM  JetPack(LiveData ViewModel Repertory Room) kotlin 材料设计 NDK  WindowManager HTTP TCP/IP
 */
public class DataSummary {

    /***
     *  一、树
     *
     *     标签： 结点 集合 有限集 结点可为空 唯一根结点 不相交子树（结点不相交）
     *
     *  1、n个结点的有限集（n>=0），n=0为空树，
     *  2、非空树中，有且只有一个根结点，除根结点外，其余的结点可分为m个互不相交的有限集，
     *      每个集合又是一棵树，称作根的字数
     *
     * 二、树的结点
     *
     *      标签：数据、若干引用
     *
     *  1、结点：包含一个数据元素、以及若干指向其子数的引用
     *
     *  2、结点的度（Degree）：结点拥有的子树个数
     *  3、叶子结点（终端结点）：度个数为0
     *  4、分支结点（非终端结点）：结点的度不为0，除了根结点外，也称为内部结点
     *
     *  5、树的度：树内各结点中度的最大值
     *
     *
     *  三、结点间关系
     *
     *      标签：双亲、孩子、兄弟、祖先、子孙
     *
     *  0、双亲结点 -> 子树（根结点（孩子结点） -> 结点 ........）
     *  1、孩子结点：某结点下子树的根
     *  2、双亲结点：孩子结点的父结点
     *  3、兄弟：同一双亲的孩子之间成为兄弟
     *  4、结点的祖先：从根结点到该结点所经过的所有结点
     *  5、子孙：某子树中根结点一下的结点
     *
     *  四：Other
     *
     *  1、结点的层次：从根开始，根为第一层，根的孩子第二次，以此类推
     *  2、堂兄弟：双亲在同一层的结点
     *  3、树的深度（高度）：树中结点的最大层次
     *
     *
     ***************** （从0开始版本）
     *
     *  树的高度 (自下而上)
     *
     *  1、空树高度 = -1
     *  2、单节点树高度 = 0
     *  3、树高度 = 树中各个结点深度的最大值
     *  4、特别低：树的高度等于根结点的高度，height(T) = height(r)
     *
     *  结点的深度（自上而下）
     *
     *  1、根结点r的深度 depth(r) = 0
     *  1、根结点r到结点v的唯一路径所经过的边数，叫做：depth(v)
     *
     *  层次
     *
     *  1、约定：根结点r的深度 depth(r) = 0，故属于第0层
     *  2、层次从0开始
     *
     ***************** （从0开始版本）
     *
     *  五、对比
     *
     *  1、树结构：
     *        根结点 、叶结点、  中间结点
     *  2、线性结构：
     *        首元素、 尾元素、 中间元素
     *
     *  六、树的抽象数据类型 ADT
     *
     *  七、树的存储结构
     *
     *   1、双亲表示法
     *   2、孩子表示法
     *   3、孩子兄弟表示法
     *
     *
     * 一、二叉树
     *
     *  1、n个节点的有限集合，集合空为空二叉树，或由一个根节点及其不相交的左子树与右子树组成
     *
     * 二、二叉树特点
     *
     *  1、每个结点最多两棵子树，结点度最大为2
     *  2、左右子树是有序的，不能颠倒
     *  3、某结点只有一棵树，也要区分左右子树
     *  4、五种基本形态：
     *      空二叉树
     *      只有一个根结点
     *      根结点只有左子树
     *      根结点只有有子树
     *      根结点左右子树
     *
     *  5、斜树：左斜树、有斜树
     *  6、满二叉树：所有分支节点都存在左右子树，叶子结点在同一层
     *  7、完全叉树：与同样深度的已编号满二叉树中结点位置与编号所对应
     *
     * 三、二叉树的性质
     *
     * 四、二叉树的存储结构
     *
     *  1、二叉树顺序存储结构
     *      完全二叉树可使用顺序存储结构
     *      右斜树使用顺序存储结构浪费内存空间
     *
     *  2、二叉链表
     *      数据域|左指针|右指针
     *
     *
     * 五、遍历二叉树
     *
     *   1、二叉树遍历：从根结点开始，以某种次序访问二叉树中所有结点，每个结点仅被访问一次
     *
     *   2、前序遍历
     *      若为空：空操作返回
     *      否则：先访问根节点，然后前序遍历左子树，再前序遍历右子树
     *
     *      根节点
     *          -> 左子树 （根节点 -> 左子树 -> 右子树）
     *          -> 右子树 （根节点 -> 左子树 -> 右子树）
     *
     *  3、中序遍历
     *      从根结点开始，先中序遍历根结点的左子树，然后访问根结点，最后中序遍历右子树
     *
     *      左子树 --  根结点 -- 右子树
     *      左叶子 -- 根 -- 右叶子
     *
     *
     *   4、后序遍历
     *      从左到右，先叶子，后结点，遍历访问左右子树，最后访问根结点
     *
     *     左子树 （ 左叶子 -> 右叶子  -> 根 ）
     *          -> 右子树 （ 左叶子 -> 右叶子  -> 根 ）
     *          -> 根
     *
     *   5、层序遍历
     *      从第一层（根结点）开始访问，从上而下逐层编列，同一层中从左到右个的顺序
     *
     *      上 -> 下
     *          左 -> 右
     *
     *
     * 六、树转换为二叉树
     *
     *  1、转换步骤：
     *      加线：所有兄弟结点间加线
     *      去线：所有结点，只保留与左孩子连线，删除其他连线
     *      参差调整：旋转
     *
     * 七、赫夫曼树
     *
     *  1、路径长度：两结点间路径上的分支数
     *  2、数的路径长度：树根到每个结点间的路径之和
     *  3、赫夫曼树：带权路径长度WPL最小的二叉树（最优二叉树）
     *          从小大大排序，1、2作为新结点N的左右子结点，N再与3组合，以此类推
     *  4、赫夫曼编码
     *      赫夫曼树做分支代表0，有分支代表1，从根结点到叶子结点组成的0101序列为叶节点对应字符的编码
     *
     *
     */

    /***
     *  二叉树的性质
     *
     *  1、各层结点个数：n层，至多2^(n-1)结点，（n>=1） 1 2 4 8 16 ...
     *  2、二叉树结点数：k层，至多2^k-1
     *  3、度为2的结点数 = 叶子结点数 - 1
     *  4.。。。。。。。。。。
     *
     */

    /***
     * 二叉树存储结构探讨
     *
     *  1、二叉树顺序存储结构
     *
     *     结论  完全二叉树可使用顺序存储结构
     *           右斜树使用顺序存储结构浪费内存空间
     *
     *
     *    a) 说明：使用一维数组存储二叉树中的节点，通过数组下表体现结点间逻辑关系（双亲及孩子、左右兄弟关系）
     *
     *    b）完二叉树：将完全二叉树按照层序遍历（广度优先）编号，编号可对应数组下表构建一维数组
     *         下标：1 2 3 4 5 6 7 8 9 10
     *         数组：A B C D E F G H I J
     *    c) 一般二叉树：通过b)方式编号，空的左右结点也编号，构建一维数组时，编号结点为空处留空
     *         下标：1 2 3 4 5 6 7 8 9 10
     *         数组：A B C D _ F G H I _
     *
     *    D) 特殊情况：右斜树（深度为K），需要分配2^k-1个存储单元
     *       如果右斜数节点为4，则空闲 2^4-1-4 = 11个
     *
     *
     *
     */

    /***
     *
     * 表达式树
     *
     */

    /***
     * 存储结构查找对比
     *
     * 1、vector
     *      无需查找find(): 逐个对比，最坏需要O(n)时间
     *      有序查找search()：利用二分查找策略，单次查找可在O(log(n))时间内完成，
     *      缺点：向量自身发生改变，如插入删除，最坏情况需要O(log(n))时间
     * 2、List
     *      find()\search() 最坏情况需要线性时间
     *
     * 3、基于向量或列表底线的栈和队列，一般地不提供任何成员的查找接口
     *
     * 4、及要求对象集合的组成可以高效的动态调整，同时也能够高效的查找？
     *
     * 5、AVL树：在最坏情况下，单次动态修改和静态查找均可以在O(log(n))时间
     *
     */

    /***
     *  关键码访问（搜索、查找）
     *
     *  1、与循秩访问、循位置访问完全不同，查找过程与结果，仅仅取决于目标关键啊
     *
     *  2、词条Entry
     *      a)比价器 >、< (Comparable)
     *      b)判等器 == 、!=  (equals)
     *
     *  3、基于有序词条，将二分查找技巧融入二叉树结构
     */


    /***
     *
     * 二叉排序树(二叉搜索树)
     *      二叉树在查找中的应用
     *
     *  -1、任何一个二叉树是二叉搜索树，当且仅当其中序遍历序列单调非降
     *
     *  0、二叉查找树的平均深度(平均查找长度)为log（N）
     *
     *  1、如果查找的数据集是有序线性表，且顺序存储，
     *          查找可用折半、插值、斐波那契等查找算法
     *          有序，在插入删除时需要耗费大量时间
     *  2、目标：插入 查找 同样高效
     *
     *  3、二叉排序树：（二叉查找树），或者为空树，或者：
     *          a)若左子树不为空，则左子树上的所有结点都小于它的根结点的值
     *          b)若右子树不为空，则右子树上的所有结点都大于它的根结点的值
     *          c)左右子树也分别为二叉排序树
     *          d)中序编列结果为从小到大有序序列
     *
     *     目的：并不是为了排序，而是为了提高查找、插入、删除关键字的速度
     *           在有序数据集上查找，速度总是快于无需数据集
     *
     *  4、增删
     *      删除时：
     *          无子节点（直接删除）、有一个子节点（删除后子节点上移）
     *          两个子结点（删除后上移直接前驱或直接后继）
     *
     *  5、链式存储结构、插入删除方便，不用移动元素
     *
     *  6、查找元素
     *      取决于树的深度，最少查找1次，最坏为树的深度
     *      缺点：二叉排序树的形状是不确定的
     *
     *  7、期望：二叉排序树比较平稳，其深度与完全二叉树相同，近似折半查找
     *
     */

    /**
     *  二叉查找树算法
     *
     *  1、查找算法：从树根出发，逐步缩小查找范围，直到发现目标（成功）或缩小至空树（失败）
     *
     */

    /**
     *
     *  平衡二叉树（AVL树）
     *
     *  1、是一种二叉排序树，其中每个结点的左子树与右子树的高度差至多等于1
     *  2、平衡因子BF = 二叉树左子树的深度 - 右子树的深度 （-1,0,1
     *
     *  AVL旋转
     *
     *      单旋转：
     *
     *      * 以节点node的左孩子为轴右旋（顺时针）转90度
     *      *
     *      * 上升node.left节点，node.left结点的右孩子给node节点，下降node结点，
     *      *
     *      * 结构如下：
     *      *
     *      *      *      *       *
     *      *     *      *       *
     *      *    *        *     * *
     *      *
     *
     *
     *      * 以节点node的右孩子为轴左旋（逆时针）
     *      *
     *      * 上升node.right节点，node.right结点的左孩子给node节点，下降node结点，
     *      *
     *      * 结构如下：
     *      *
     *      *        *      *      *
     *      *         *      *      *
     *      *          *    *      * *
     *
     *      双旋转：
     *
     *
     *   插入效率:
     *      在O(log(n))时间内插入新节点，
     *      至多检查O(log(n))个节点即可确定g(x)（失衡节点）
     *      如有必要，至多旋转两次，即可使局部乃至整棵树恢复平衡
     *      AVL树的节点插入时间在O(log(n))内
     *
     *   删除效率
     *      会失衡传播，相较插入操作，删除操作在重平衡方面需要花费更多时间
     *      重平衡直多需要O(log(n))时间
     *      AVL树的节点删除操作总体的时间复杂度依然是O(logn)
     *
     */

    /**
     *
     *  伸展树
     *
     *    0、数据访问的局部性，按照“最常用者优先”策略
     *
     *    1\数据局部性：
     *      a) 刚刚被访问的元素，极有可能在不久后再次被访问到
     *      b) 将被访问的下一元素，极有可能就处于不久之前被访问过的某个元素的附近
     *
     *    2、简易伸展树
     *      每访问过一个节点之后，随即反复地以它的父节点为轴，经适当的旋转将其提升一层，直至最终成为树根。
     *      随着节点E的逐层上升，两侧子树的结构也不断地调整，故这一过程也形象地称作伸展（splaying）
     *
     *      效率：单次访问的分摊时间复杂度在极端情况下可能高达O(n)。
     *
     *    3、双层伸展树
     *      克服上述伸展调整策略的缺陷，一种简便且有效的方法就是：将逐层伸展改为双层伸展
     *      每次都从当前节点v向上追溯两层（而不是仅一层），并根据其父亲p以及祖父g的相对位置，进行相应的旋转。
     *
     *      效果与效率
     *      a) 伸展树虽不能杜绝最坏情况的发生，却能有效地控制最坏情况发生的频度，从而在分摊意义下保证整体的高效率
     *      b) 双层伸展树的单次操作均可在分摊的O(logn)时间内完成
     *      c) 可“智能”地“折叠”被访问的子树分支，有效地避免对长分支的连续访问。
     *      d) 即便节点v的深度为(n)，双层伸展策略既可将v推至树根，亦可令对应分支的长度以几何级数（大致折半）的速度收缩
     *
     *
     *
     *
     *
     *
     */

    /**
     *
     *  多路查找树（B树）
     *
     *  1、多路查找树：其每一个结点的孩子数可以多余两个，且每一个结点处可以存储多个数据
     *
     *
     *  2-3树
     *
     *  1、其中每一个结点都具有两个孩子（2结点）或三个孩子（3结点）
     *  2、2结点包含一个元素和两个孩子（或没有孩子），与二叉排序树类似，要么每孩子要么有两个孩子
     *  3、3结点好汉一大一小两个元素和三个孩子（或没有孩子），
     *      左子树元素<(根结点最小元素)，中子树介于小元素与大元素之间，右子树大于根结点最大元素
     *  4、2-3树叶子结点都在同一层上
     *  5、复杂情况：在于新节点的插入与已有结点的删除
     *
     *  2-3-4
     *
     *  1、4结点包含大中小三个元素、4个人孩子结点（或没有孩子）
     *
     *  B树
     *
     *  1、平衡的多路复用树
     *  2、B树的阶：结点最大的孩子数目，2-3树的阶为3,2-3-4树的阶为4
     *
     *  B+树
     *
     *
     *  B树的分解策略：
     *
     *      1、自底向上：去分解父结点的结点，直到不需要分解为止
     *      2、自上而下：二分搜索的过程，一旦遇到满结点就分解它，这样在最终插入的时候永远不会有父结点是满结点的情况
     *
     *
     *
     *
     */

    /**
     *  红黑树
     *
     *      0、任一节点左、右子树的高度，相差不得超过两倍。
     *
     *      1、条件
     *        (1) 树根始终为黑色
     *        (2) 外部节点均为黑色
     *        (3) 其余节点若为红色，则其孩子节点必为黑色
     *        (4) 从任一外部节点到根节点的沿途，黑节点的数目相等
     *
     *      2、平衡性：
     *          其高度仍控制在最小高度的两倍以内，仍是O(logn)
     *
     *      在每次插入或删除操作之后的重平衡过程中，全树拓扑结构的更新仅涉及常数个节点。尽管最坏
     *          情况下需对多达(logn)个节点重染色，但就分摊意义而言仅为O(1)个
     *
     *
     *  插入删除：
     *      1、重新着色和旋转用于保持红黑属性
     *
     *      插入操作中：检查叔叔的颜色来决定适当的情况，违反：属性编号3（红色节点有黑色子节点）
     *      删除操作中，检查兄弟的颜色，  违反：属性是属性编号4（从某个节点到叶子的任何路径中的黑色节点数量相同）
     *
     *
     *  删除：
     *
     *      设x为要删除节点，y替换树中x节点
     *      1、替换节点Y为红色，(不管X为红色或者为黑色)
     *          处理;用替代节点Y的值替换X的值，颜色保持不变，之后删除Y节点 （将替代后的y颜色变为删除结点的颜色）
     *
     *      2、替换节点y为黑色）-- (X和Y都是黑色的)
     *         “双黑”: 因某一无红色孩子的黑节点被删除，而导致的此类复杂情况
     *
     *          S黑色
     *          a、X的兄弟节点S为黑色，S的孩子中至少有一个是红色（包括两红）（设一个红色节点为R），分为四种情况     *
     *              右子树情况：
     *
     *              a.1、右翼情况：兄弟S是右孩子，R是S的右孩子
     *                   处理;以兄弟S为轴左旋，使得S变为根节点，S的右孩子（左孩子）R标记为黑色
     *              a.2、左右情况：兄弟S是右孩子，R是S的左孩子
     *                   处理;以兄弟S为轴右旋，使得R变为字树根节点，再以R为轴左旋，使得R变为根节点，将R标记为黑色
     *
     *              左子树情况（镜像）
     *              a.3、左左情况：兄弟S是左孩子，R是S的左孩子(同上)
     *              a.4、左右情况：兄弟S是左孩子，R是S的右孩子(同上)
     *
     *          b、X的兄弟节点S为黑色，S的两个孩子都为黑色，（s的子樹多一个黑节点，所以标记S为红色，之后再判断其父节点P的状态）
     *               处理;  执行重新着色，然后如果父级是黑色则重复父级。如果父母是红色的，那么我们不需要重复它，
     *               我们可以简单地使它变黑（红色+双黑色=单个黑色）
     *
     *               处理;将兄弟节点S标记为红色，将S的父节点P作为替代节点（当前删除节点），重新进行删除节点情景处理
     *
     *          S紅色
     *          c、黑色X的兄弟节点S为红色，S的父节点必然为黑色，S的孩子必为黑色（且至少有一个），因为保证删除前的黑平衡
     *              右子树情况：
     *
     *              c.1、右侧情况：兄弟S是右孩子
     *                   处理;以兄弟S为轴左旋，使得S变为根节点，标记S为黑色，之前S的父节点为红色,之後处理情况b
     *              c.2、左侧情况：兄弟S是左孩子
     *
     *
     *
     *
     */

    /***
     *
     *  图
     *
     *  1、顶点（有穷、非空）+ 边集合 - G(V，E):G表示图，V表示顶点，E表示边
     *  2、邻接矩阵
     *  3、邻接表
     *
     *
     *  图的遍历
     *
     *  1、从图虫某一顶点出发访问其余各顶点，且各顶点仅被访问一次
     *  2、深度优先遍历
     *  3、广度优先遍历
     *  4、最小生成树
     *  5、最短路径
     *
     *
     *
     *
     *
     */

    /***
     * 1、寻秩访问   rank    Vector
     * 2、寻位置访问   position    List
     * 3、寻关键码访问     key         BST
     * 4、寻数值访问      value       散列（哈希）hashing
     *
     */

    /***
     *
     *  词典
     *
     *  散列:（便捷、）
     *      0、散列存储技术：通过查找关键字不需要比较既可以获得记录存储的位置
     *          在数据的存储位置与数据的关键字key之间建立的一个确定的关系f,使得每个关键字key对应一个存储位置f(key)
     *          散列是一种存储方法，也是查找方法
     *          散列主要是面向查找的存储结构
     *          散列技术最适合的求解问题是：查找与给定值相等的记录
     *          不适合的情况：范围查找、表中记录的排序、最大最小值
     *
     *      1、桶（bucket）: (存储位置)直接存放或间接指向一个词条（数组中的每一个成员）
     *           桶数组（bucket array） | 散列表（hash table） 容量为m, 散列表长度的选取
     *           散列地址空间以及关键码空间
     *
     *      2、定制/杂凑/散列（Hashing)
     *          根据词条的key（未必可比较），直接确定散列表入口
     *
     *      3、散列函数：hash() : key --> &entry
     *          a、hash(key) = key % M
     *
     *      4、装填因子(Load factor)：入 = N/M  （N个数 M容量）
     *
     *      5、散列冲突
     *          f(key1) = f(key2), 降低散列因子（增大M容量）
     *
     *      6、设计与定制
     *          精心设计散列表以及散列函数，以尽可能降低冲突的概率
     *          冲突的排解技巧？
     *
     *          什么样的散列函数hash()更好？
     *          a、确定性determinism：同一关键码总是被映射至统一地址
     *          b、快速efficiency：expected O(1) 快粗查找到
     *          c、满射surjection: 尽可能充分地覆盖整个散列空间，降低冲突概率
     *          d、均匀uniformity：关键码映射到散列表各位置的概率尽量接近，可有效避免聚集clustering现象
     *
     *      7、散列函数的构造方法
     *         设计一：除余法 hash(key) = key % M
     *         a、取M = 2^k
     *         缺点：
     *              不动点：无论表长M取值如何，总有hash(0) = 0
     *              零阶均匀：相邻关键码的散列地址也必然相邻
     *
     *         b、取M素数，数据对散列表的覆盖最充分，分布最均匀
     *
     *         设计二：MAD法（multiply-add-divide）
     *              一阶均匀：领进的关键码，散列地址不再接近
     *              去M为素数，a(步长step)>0 , b(偏移量offset)>0 , a%M（容量）!=0
     *              hash(key) = (a * key + b) % M
     *
     *         特殊场合下，未必需要高阶的均匀性，如（临近的关键码被映射到临近位置）Locality Sensitive Hashing
     *
     *         例如：将更大的空间散列映射压缩至一个相对而言为更小的空间，反之也大有用处（密码学）
     *
     *          更多散列函数
     *          数字分析、折叠发（自左至右、往复折返）。。。
     *
     *          伪随机数法
     *                rand(x + 1) = = (a * rand(x)) % M //x系统当前时间，
     *
     *          总之，散列函数：越是随机、越是没有规律，越好
     *
     *      9、关键码转为整形 hashcode
     *          字符串型：
     *              多项式法: (复杂)
     *
     *      10、多槽位（槽不確定性）
     *
     *          独立链
     *          优点：
     *              无需为每个桶预留多个槽位
     *              任意多次的冲突都可以解决
     *              删除操作实现简单、同意
     *          缺点：指针需要额外空间
     *                空间未必连续分布，系统缓存几乎失效（无法通过缓存加大查找速度）
     *
     *          开放定址 闭散列
     *              桶具有优先级
     *
     *     11、约定查找链
     *          线性试探
     *          平方试探
     *
     *    12、散列表取素数M = 4 * k + 3 (Mod 4 余 3)
     *
     *    13、桶/计数排序 O(max(n,m))
     *
     */

    /***
     *
     *  优先级队列（数据结构）
     *
     *  1、队列，通过优先级访问（不是先进先出）
     *  2、多任务调度，任务指标有大小，指标大（优先级高）的优先
     *
     *  典型模式：寻优先级访问
     *
     *  ADT: inset()\getMax()\deleteMax()\size()
     *
     *  3、实现优先级队列（效率，成本）
     *      a、基于（无序）向量方式，有序向量方式 --> 高效性不满足
     *      b、基于列表LIst -->高效性不满足
     *      c、BBST --> 杀鸡用牛刀 大材小用
     *      d、参照BBST 使用完全二叉树 -- 称作（完全二叉堆）
     *
     *  4、结构性：
     *      逻辑上：等同于完全二叉树
     *      物理上：直接借助向量实现
     *      逻辑结点与物理元素之间的关系：依层次遍历次序彼此对应
     *      “堆序性”:就优先级而言，堆顶以外的每个节点都不高（大）于其父节点
     *
     *  5、完全二叉堆
     *      插入：只需要将x作为末元素接入向量，若x大于其父亲，则与之互换位置
     *          上滤：新插入的节点逐层上滤，首先将节点插入末尾，然后逐层上滤
     *          效率：O(log(n))
     *      删除：（删除最大元）
     *          下滤：被删除的节点逐层下滤,首先将末节点替换至堆顶，然后逐层下滤（对内部节点下滤）
     *          效率：KO(log(n))
     *
     *  6、批量建堆
     *      a、heapify() 蛮力插入（自上而下逐一上滤）
     *          效率：最坏情况 O(n * log(n))（对深度求和） -->该时间足以全排序
     *
     *      b、（自下而上的下滤）H1 - P - H2 ，将r0和r2当做p的孩子，对p下滤
     *          左子堆与右子对分别将父节点下滤，直到最后的堆顶下滤完毕，则构建完成
     *          效率：O(n) （对高度求和）
     *
     *      c、初始化堆（建堆）：O(N)
     *         迭代：O(log(n))
     *         总共：O(n * log(n))
     *
     *  7、堆排序算法
     *      a、替代简单的线性结构，如选择排序结构
     *      b、空间复杂度方面可以做的更好
     *      c、使用堆的物理结构向量进行排序，
     *         首先将待排序数据建堆（O(n)），然后自下而上对内部节点下滤，保证堆序性(O(log(n)))，
     *         然后执行delMax(v)将堆顶的最大值与末尾结点交换，奖最大值放入排序完成位置，之后依次下滤删除，直至排序完成
     *
     *  8、左式堆
     *     a、动机：有效完成堆合并
     *        左式堆：保持堆序性，在堆合并过程中，只需调整很少部分的节点（节点数logn个）
     *        物理结构使用二叉树结构
     *        效率:O(log(n))
     *
     *     b、空节点路径长度（Null Path Length）
     *        npl(null) = 0
     *        npl(x) = x到外部节点的最近距离
     *        npl(x) = 以x为根的最大满子树的高度
     *
     *     c、左倾性：
     *        任何内部节点：都有npl(lc(x)) >= npl(rc(x))
     *        任何内部节点：都有npl(x) =  1 + npl(rc(x))
     *        左倾性与堆序性不矛盾
     *        左式堆的子堆，必是左式堆
     *        左式堆倾向于更多节点分布于左侧分支
     *
     *     d、右侧链：
     *        从节点x出发，一直沿着右分支前进 右侧链的长度 <= O(logn)
     *
     *   9、左式堆合并算法
     *      insert节点基于合并算法
     *      delMax基于合并算法，删除堆顶节点，之后合并左子堆与右子堆
     *
     */

    /***
     *
     *  串(字符串)
     *  0、由0个或多个字符组成的有限序列，又名字符串
     *
     *  1、字符串S[0,n)
     *     子串、前缀、后缀、空船
     *     长度严格小于前缀（子串|后缀）的子串，称为真前缀（真子串|真后缀）
     *
     *  2、串匹配
     *      Pattern matching
     *      detection first-location counting enumeration
     *
     *  3、算法测评
     *     a、蛮力匹配
     *        效率：最好情况（O(m)）最坏情况（O(n * m)） m为模式串 n为给定的查找文本串
     *
     *  4、KMP算法
     *     最坏情况 O(n)
     *     预先感知模式串j移动的位置
     *     排除对其位置，快速后移
     *
     *  5、构造查找表，建立预案
     *
     *  6、规律：j值的多少，取决于当前字符串之前的串的前缀与后缀的相似度
     *     将模式串P各个位置的j值的变化，定义为一个数组next，next的长度就是模式串P的长度
     *     函数定义：
     *         next(j) = 0，当j=1时
     *                 = 1，其他情况
     *                 = Max{k| 1 < k < j , 且p(1)...p(k-1) = p(j-k+1)...p(j-1)},次集合不为空时
     *
     *     如果前后缀n个字符相等，k=n+1
     *
     *  7、列出模式串的所有前缀（包含自身），在每个前缀中找到公共前后缀列表的最大值k
     *
     *    如下
     *          a b a b c   最长公共前后串的长度
     *                       --  -1
     *          a            --  0
     *          a b          --  0
     *          a b a        --  1
     *          a b a b      --  2
     *          a b a b c    --  0 (不需要)
     *
     *    位置    =  0,1,2,3,4
     *    模式串p =  a b a b c
     *    next[] = {-1,0,0,1,2}
     *
     */

    /**
     *  排序
     *
     *  性能：時間性能、輔助空間、算法的复杂性
     *
     *  内排分为：插入排序、交换排序、选择排序、归并排序
     *
     *
     *  众数：无序向量中，若有一半以上元素同为m,则称之为众数
     *
     *
     */

    /**
     *
     *  HashMap
     *    1.7: 数组 + 链表
     *    1.8  数组 + 链表 + 红黑树
     *
     *    -1、基于哈希表实现原理
     *    0、允许key、value为空
     *    1、初始容量：16,  必须为2的幂次
     *    2、装载因子：0.75
     *    3、触发扩容的阈值threshole = 实际存放节点数 = capacity * load factor
     *    4、链表转红黑树阈值：8 , 大于8时
     *    5、红黑树转链表阈值：6 ， 等于6时
     *    6、扩容为原来容量的2倍 ==》   newThr = oldThr << 1
     *    7、非线程安全
     *    8、继承自AbstractMap
     *    9、插入结点时无序的
     *
     *    查找流程：
     *    1、调用 public V get(Object key)方法
     *    2、计算hash(key)值，
     *          return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
     *    3、调用 final Node<K,V> getNode(int hash, Object key)方法
     *       a、判断散列表不为空，大于0，hash(key)桶位置的Entity不为空
     *       b、桶位置Node与待查找的hash值相等并且key相同
     *          return 查找成功Node
     *
     *       c、桶位置不成功，查找下一节点，
     *       d、下一节点如果为TreeNode(红黑树结点)，调用红黑树查找结点方法查找
     *            ((TreeNode<K,V>)first).getTreeNode(hash, key);
     *            ----找根结点----
     *            d1、判断桶位置的节点是否为根结点，从根结点开始查找
     *                 return ((parent != null) ? root() : this).find(h, k, null);
     *            ----Hash比较-------
     *            d2、树结点hash大于待查找节点Hash,向左子树查，小于向右子树查找
     *            d3、若Hash值相等并且key也相等，则查找成功
     *                return TreeNode
     *            d4、Hash值相等,Class<?> kc(key比较器)不为空,待查找key小于树结点key向左子树查找，大于向右子树查找
     *            d5、Hash值相等，向左子树查询，向右字数查询     *
     *
     *
     *       f、否则遍历单链表的方式查找
     *           do {
     *                     if (e.hash == hash &&
     *                         ((k = e.key) == key || (key != null && key.equals(k))))
     *                         return e;
     *                 } while ((e = e.next) != null);
     *
     *
     *   插入流程
     *      1、散列表为空或容量为零，初始化或加倍表容量
     *           final Node<K,V>[] resize()
     *      2、待插入Node的桶入口处为空，直接插入
     *           tab[i] = newNode(hash, key, value, null);
     *      3、桶位置Node不为空，
     *          a、Hash与key都相同（待插入值已存在）
     *             如果老值为空，则用新值替换
     *             onlyIfAbsent if true, don't change existing value
     *             return 老值（老Node）
     *          b、桶位置结点为树结点,.通过红黑树插入
     *              ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
     *              b1、找到根结点
     *              b2、判断hash值，向左向右子树查找，若hash值相同并且key也相同，则返回执行a的判断
     *              b3、仅Hash值相等情况
     *                  在左子树或右子树中通过查找流程查找该待插入数据的hash与key是否存在，存在就返回
     *                  若不存在，比较key的大小（若key实现了比较器）
     *                  当前节点的左子树或右子树为空，根据dir(key比较值)将待插入数据放入左子树或右子树
     *                  维护插入结点x的parent、next、prev关系
     *                  之后执行红黑树插入平衡balanceInsertion(root, x)
     *                  平衡完成后会得到新的树根root
     *                  之后确保新的树根在桶位置（第一个节点），将根结点的noxt与prev关联，根结点放入第一个位置，first节点放入next之后
     *          c、单链表插入，如果下一个节点不为空并且hash与key相同则返回执行a的判断,
     *              若果next节点为空，直接插插入，如果单链表节点数超过8个，就转化为红黑树结构存储节点数据
     *      4、修改次数modCount++，size(映射关系个数)大于threshold(阈值 = 装田因子 * 总容量)，则扩容resize
     *      5、如果是linkedHashMap,则最后执行 afterNodeInsertion(evict);判断删除策略removeEldestEntry
     *
     *  LinkedHashMap
     *      1、继承自HashMap
     *      2、通过维护一条双向链表，解决插入顺序与遍历顺序一致
     *          before、after结点为各节点的前驱后继
     *          head、fail为双链表的首尾指针
     *      3、可以实现缓存策略，通过removeEldestEntry(),插入后可以删除最老的节点数据
     *
     *  多线程处理非线程安全的结构时：
     *      迭代器不容去迭代遍历时内部结构修改，否则抛出ConcurrentModificationException
     *
     *  HashTable
     *      1、物理结构：哈希表实现
     *      2、key、value都不能为空
     *      3、key必须实现hashcode()、与equals（）方法
     *      4、性能取决于装填因子，与表容量（桶个数）
     *      5、哈希冲突后查找是线性的
     *      6、load factor 填充因子默认为0.75，空间换时间，减少冲突
     *      7、是线程安全的，在非多线程情况下建议使用HashMap,在多线程情况下建议使用ConcurrentHahMap
     *      8、集成于Dictionary，实现Map
     *      7、默认初始容量为11
     *      8、reHash()时，重新创建新的桶数组，对老数据根据新的哈希表重新进行哈希运算计算位置并填充
     *      9、hash算法 = (hash & 0x7FFFFFFF) % tab.length
     *      10、插入时，hash与key都相同，新值替换老值
     *
     *
     */

    /***
     *
     *  ConcurrentHashMap
     *
     *    1.7实现原理
     *
     *    1.数组 + Segment + 分段锁结构
     *    2.Segment(分段锁)
     *      类似于HashMap的结构，内部为数组 + 链表结构，
     *      集成自ReentrantLock
     *    3.ConcurrentHashMap使用分段锁技术，将数据分为一段一段的存储，然后给每一段数据配一把锁，
     *      当一个线程占用锁访问一个段（Segment）数据时，其他段的数据也可以同时被其他线程访问，实现并发访问
     *      结构如下：     *
     *      ConcurrentHashMap 多个Segment( 数组 --> 链表 )
     *    4、定位一个元素需要进行两次Hash操作
     *      第一次Hash定位到Segment，第二次Hash定位到桶位置（链表头部）
     *    5、劣势：
     *      Hash的过程比普通的HashMap长
     *    6、优势
     *      写操作时只需要对元素所在的Segment加锁即可，不会影响其他Segment,
     *      理想情况下，最高并发数可为Segment的个数，可提高并发能力
     *
     *    1.8实现原理
     *
     *    1、数组 + 链表 + 红黑树，内部大量采用CAS操作
     *    2、CAS(compare and swap) 比较交换，是一种基于锁的操作，而且是乐观锁
     *       a、悲观锁：将资源锁住，等之前获得资源的线程释放锁后，下一个线程才可以访问
     *       b、乐观锁：一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能优于悲观锁
     *       c、包含三个操作数：内存位置（V）、预期原值（A）、新值（B）
     *          如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行
     *    3、采用CAS+Synchronized保证线程安全
     *    4、锁的粒度：现调整为对每个数组元素加锁（Node）
     *    5、查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。
     *
     */

    /***
     *
     *  HashSet
     *
     *  1、基于hashMap、LinkedHashMap实现
     *  2、HashSet的值保存到HashMap的key处
     *  3、插入值时，
     *          在HashMap中桶为空，直接插入
     *          在HashMap中检查Hash相同，Key相同，若相同，用新的值（PRESENT）替换老的值（PRESENT）
     *          在HashMap中检查Hash相同，Key不同，则插入链表或转为树
     *  4、所以，HashSet的值 => 无序、不可重复
     *
     */

    /***
     *
     *  TreeMap
     *
     *  1、红黑树实现，结点（key）是可排序的
     *     对象实现Comparable   -- a.compareTo(b)
     *     构造参数Comparator  -- compare(a,b)
     *  2、key不能为空，key相同的结点，新值覆盖老值
     *
     *  TreeSet
     *
     *  1、基于TreeMap实现
     *  2、TreeSet的值 == TreeMap的key ==> 有序，不可重复，不能为空
     *
     */

    /***
     *
     *  ArrayList
     *
     *  1、列表结构，数组实现，Object[] elementData
     *  2、无参构造函数创建的List容量为空，默认容量为10，扩容时，若首次扩容，选取容量为max(10,minCapacity)
     *  3、扩容或删除都是复制移动数据
     *  4、值可空
     *  5、扩容为：
     *          正常扩容：oldCapacity + (oldCapacity >> 1);
     *          与期望容量比较：小于期望容量则用期望容量minCapacity
     *          判断大容量：hugeCapacity()
     *          最后：Arrays.copyOf(...) ->  System.arrayCopy(.....)
     *
     *  LinkedList
     *
     *  1、双链表实现
     *  2、可作为双端队列，也可作为栈
     *  3、各个插入删除操作分为返回空版本和抛异常版本
     *  4、值可空
     *
     *  queue:
     *    add
     *      (first)
     *      peek、element （see）
     *      poll、remove   (see remove)
     *      offerFirst
     *
     *      (last)
     *      offer
     *      offerLast
     *
     *  LinkedList<Integer> queue = new LinkedList<>();
     *  queue.offer(1); //加入队尾(linkfirst)
     *  queue.offer(2);
     *
     *  queue.pollLast()//出队
     *
     *
     *  stack
     *    add
     *      push() -> (addFirst)
     *    remove
     *      pop() -> (removeFirst)
     *
     *   LinkedList<Integer> stack = new LinkedList<>();
     *   stack.push(1)
     *   stack.push(2)
     *
     *   int i = stack.pop()
     *
     */



    /**
     *  ThreadLocal
     *
     *  ThreadLocalMap
     *     1、哈希表结构，用于维护线程本地值，ThreadLocal私有类
     *     2、Entry多key使用弱引用
     *     3、初始值为6
     *     4、Entry[] table的容量可以扩容，长度必须为2的幂次方
     *
     *
     *
     *
     *
     *
     */

    /***
     *
     *  Collection
     *      AbstractCollection
     *          AbstractList
     *              List
     *
     *
     *
     */

    /**
     *  transient：让某些被修饰的成员属性变量不被序列化
     *
     *
     *  迭代器
     *      关键字：
     *          cursor:迭代器游标，默认为0，hasNext()或next()等都是通过游标取值
     *          modCount:并发修改判断，ConcurrentModificationException
     *
     *  iterator
     *      顺序向后遍历、是否有值、删除
     *      作用范围：应用于所有集合（List、Set、Map及子类）
     *      仅能遍历，不能修改。
     *  ListIterator
     *      逆向（顺序向前）遍历、
     *      只能用于List及其子类型。
     *      有add方法，可以向List中添加对象，
     *      可以定位索引的位置
     *      可以实现对象的修改，set()方法可以实现
     *
     *
     */

}
